// DO NOT EDIT. This file is autogenerated by aapi-codegen
package <%= it.package %>

<%
	var parametersExists = it.channels
		.map(channel => channel.parameters.length > 0)
		.filter(hasParameters => hasParameters)
		.length > 0

	var hasSubscriber = it.receivers.length > 0
	var hasPublisher  = it.senders.length > 0
%>

import (
	"errors"
	<% if (parametersExists) { -%>
	"reflect"
	"strings"
	"fmt"
	"regexp"
	"context"
	<%- } %>

	"github.com/ThreeDotsLabs/watermill/message"
)

var (
	ErrUnknownMessageId = errors.New("unknown message id")
	ErrExpectedStruct = errors.New("expected a struct")
	ErrChannelMismatchesAddress = errors.New("channel mismatches address")
	ErrParameterCouldNotSetValue = errors.New("could not set value on parameter")
)

// Receive messages of channels by implementing this interface
type AsyncApiInterface interface {
	<% it.receivers.forEach(receiver => { -%>
		<% receiver.messages.forEach( message => { -%>
	// Handles operation <%= receiver.id %> with message <%= message.id %> on the <%= message.channel %> channel
			<% if (receiver.parameters.length > 0) { -%>
    <%= receiver.id %>With<%= message.name %>Msg(msg <%= message.name %>RecvMsg, param <%= message.channel %>Param) error 
    <%- } else { -%>
    <%= receiver.id %>With<%= message.name %>Msg(msg <%= message.name %>RecvMsg) error 
			<%- } %>
		<%- }) %>
	<%- }) %>
}

// Router plugin with all operations
type AsyncApi struct {
    <% if (hasSubscriber) { -%>
	handlers   AsyncApiInterface
    subscriber message.Subscriber
	<%- } %>
    
    <% if (hasPublisher) { -%>
	publisher  message.Publisher
	<%- } %>

	router *message.Router
}

func NewAsyncApi(<% if (hasPublisher) { %>publisher message.Publisher, <% } %><% if (hasSubscriber) { %>subscriber message.Subscriber, handlers AsyncApiInterface<% } %>) *AsyncApi {
	return &AsyncApi {
		<% if (hasPublisher) { -%>
		publisher: publisher,
		<%- } -%>
		<%- if (hasSubscriber) { -%>
		subscriber: subscriber,
		handlers: handlers,
		<%- } %>

		router: nil,
	}
}


func (a *AsyncApi) Plugin(r *message.Router) error {
	a.router = r

    <% it.receivers.forEach(receiver => { -%>
		<% if (receiver.parameters.length === 0) { -%>
	// Handler for receive operation <%= receiver.id %>
	r.AddNoPublisherHandler(
            "<%= receiver.channel.address %>Handler",
            "<%= receiver.channel.address %>",
            a.subscriber,
            a.wrapper<%= receiver.id %>,
	)
    	<%- } %>
	<%- }) %>

	return nil
}

<% if (parametersExists) { -%>
	<%- it.receivers.forEach(receiver => { -%>
		<%- if (receiver.parameters.length > 0) { %>
// Subscribes to channel <%= receiver.channel.id %>
func (a AsyncApi) SubscribeTo<%= receiver.id %>(param <%= receiver.channel.id %>Param) (*message.Handler, error) {
	if a.router == nil {
		panic("plugin uninitialised. call router.AddPlugin(asyncApi.Plugin) first")
	}
	
	address := marshalChannelAddress("<%= receiver.channel.address %>", param)

	handler := a.router.AddNoPublisherHandler(
		fmt.Sprintf("%sHandler", address),
		address,
		a.subscriber,
		a.wrapper<%= receiver.id %>,
	)

	if err := a.router.RunHandlers(context.Background()); err != nil {
		return nil, err
	}

	return handler, nil
}
		<% } %>
	<% }) %>


func marshalChannelAddress(address string, param interface{}) string {
	v := reflect.ValueOf(param)
	for i := 0; i < v.NumField(); i++ {
		pName := v.Type().Field(i).Tag.Get("parameter")
		pValue := v.Field(i).String()
		
		address = strings.ReplaceAll(address, fmt.Sprintf("{%s}", pName), pValue)
	}

	return address
}

func unmarshalChannelAddress(channel string, address string, param interface{}) error {
	if t := reflect.TypeOf(param); t.Kind() != reflect.Pointer {
		return ErrExpectedPointerType
	}

	pStruct := reflect.ValueOf(param).Elem()
	addressRegex := fmt.Sprintf("^%s$", address)
	for i := 0; i < pStruct.NumField(); i++ {
		pName := pStruct.Type().Field(i).Tag.Get("parameter")
		pField := pStruct.Type().Field(i).Name

		addressRegex = strings.ReplaceAll(addressRegex, fmt.Sprintf("{%s}", pName), fmt.Sprintf("(?<%= "<" %>%s>.*)", pField))
	}

	re, err := regexp.Compile(addressRegex)
	if err != nil {
		return err
	} else if !re.MatchString(channel) {
		return ErrChannelMismatchesAddress
	} else if pStruct.Kind() != reflect.Struct {
		return ErrExpectedStruct
	}
	
	subMatch := re.FindStringSubmatch(channel)
	for i, pField := range re.SubexpNames() {
		if i == 0 { continue }

		f := pStruct.FieldByName(pField)
		if f.IsValid() && f.CanSet() && f.Kind() == reflect.String {
			f.SetString(subMatch[i])
		} else {
			return ErrParameterCouldNotSetValue
		}
	}

	return nil
}
<%- } %>

<% it.channels.forEach(channel => { -%>
	<%- if (channel.parameters.length > 0) { %>
// Parameter of channel <%= channel.id %>
type <%= channel.id %>Param struct {
	<% channel.parameters.forEach(param => { -%>
	<%= param.name %> string `parameter:"<%= param.id %>"`
	<% }) %>
}
	<% } -%>
<%- }) %>


<% if (hasPublisher) { -%> 
	<%- it.senders.forEach(sender => { -%>
// Message interface for operation <%= sender.id %>
type <%= sender.id %>SendMsg interface {
	visit<%= sender.id %>SendMsg (uuid string) (*Message, error)
}
		<%- sender.messages.forEach( message => { -%>
func (m <%= message.name %>MsgPayload) visit<%= sender.id %>SendMsg(uuid string) (*Message, error) {
	msg, err := NewMessage(uuid, m)
	if err != nil {
		return nil, err
	}
	return msg, nil
}
		<% }) %>
// Publish message of operation <%= sender.id %> into channel <%= sender.channel.id %>
		<%- if (sender.parameters.length > 0) { -%>
func (a AsyncApi) Publish<%= sender.id %>(uuid string, message <%= sender.id %>SendMsg, param <%= sender.channel.id %>Param) error {
	msg, err := message.visit<%= sender.id %>SendMsg(uuid)
	if err != nil {
		return err
	}
	address := marshalChannelAddress("<%= sender.channel.address %>", param)
	return a.publisher.Publish(address, msg.Raw())
}
			<%- } else { -%>
func (a AsyncApi) Publish<%= sender.id %>(uuid string, message <%= sender.id %>SendMsg) error {
	msg, err := message.visit<%= sender.id %>SendMsg(uuid)
	if err != nil {
		return err
	}
	return a.publisher.Publish("<%= sender.channel.address %>", msg.Raw())
}
		<% } -%>
	<% }) -%>
<% } %>

<% if (hasSubscriber) { -%>
	<%- it.receivers.forEach(receiver => { %>
// Wraps the handler for the receive operation <%= receiver.id %>
func (a AsyncApi) wrapper<%= receiver.id %>(m *message.Message) error {
	msg := Message{}
	if err := msg.Load(m); err != nil {
		return err
	}

	<% if (receiver.parameters.length > 0) { -%>
	// extract parameters from channel
	channel := message.SubscribeTopicFromCtx(m.Context())
	var param <%= receiver.channel.id %>Param
	if err := unmarshalChannelAddress(channel, "<%= receiver.channel.address %>", &param); err != nil {
		return err
	}
	<% } %>

	switch msg.MsgId() {
    <% receiver.messages.forEach(message => { -%>
	case "<%= message.name %>":
		var recvMsg = <%= message.name %>RecvMsg{
			Message: msg,
		}

		<%- if (receiver.parameters.length === 0) { -%>
		return a.handlers.<%= receiver.id %>With<%= message.name %>Msg(recvMsg)
		<%- } else { -%>
		return a.handlers.<%= receiver.id %>With<%= message.name %>Msg(recvMsg, param)
		<%- } -%>
    <%- }) -%>
	default:
		return ErrUnknownMessageId
	}
}
	<% }) %>
<%- } %>
