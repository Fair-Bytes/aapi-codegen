// DO NOT EDIT. This file is autogenerated by aapi-codegen
package <%= it.package %>

<%
	var parametersExists = it.channels
		.map(channel => channel.parameters.length > 0)
		.filter(hasParameters => hasParameters)
		.length > 0
%>

import (
	"errors"
	<% if (parametersExists) { -%>
	"reflect"
	"strings"
	"fmt"
	"regexp"
	"context"
	<%- } %>

	"github.com/ThreeDotsLabs/watermill/message"
)

var (
	ErrUnknownMessageId = errors.New("unknown message id")
	ErrExpectedStruct = errors.New("expected a struct")
	ErrChannelMismatchesAddress = errors.New("channel mismatches address")
	ErrParameterCouldNotSetValue = errors.New("could not set value on parameter")
)

type AsyncApiReceiver interface {
	<% it.receivers.forEach(receiver => { -%>
		<% receiver.messages.forEach( message => { -%>
			<% if (receiver.parameters.length > 0) { -%>
	// Handles operation <%= receiver.id %> with message <%= message.id %> on a channel with parameters
    <%= receiver.id %>_<%= message.id %>(msg Message, payload <%= message.channel %>_<%= message.id %>, parameters <%= message.channel %>Parameters) error 
    <% } else { %>// Handles operation <%= receiver.id %> with message <%= message.id %>
    <%= receiver.id %>_<%= message.id %>(msg Message, payload <%= message.channel %>_<%= message.id %>) error 
			<%- } %>
		<%- }) %>
	<%- }) %>
}

// Router plugin with all operations
type AsyncApi struct {
    <% if (it.receivers.length > 0) { -%>
	receiver   AsyncApiReceiver
    subscriber message.Subscriber
	<%- } %>
    
    <% if (it.senders.length > 0) { -%>
	publisher  message.Publisher
	<%- } %>

	router *message.Router
}

func NewAsyncApi(<% if (it.senders.length > 0) { %>publisher message.Publisher, <% } %><% if (it.receivers.length > 0) { %>subscriber message.Subscriber, receiver AsyncApiReceiver<% } %>) *AsyncApi {
	return &AsyncApi {
		<% if (it.senders.length > 0) { -%>
		publisher: publisher,
		<%- } -%>
		<%- if (it.receivers.length > 0) { -%>
		subscriber: subscriber,
		receiver: receiver,
		<%- } %>

		router: nil,
	}
}


func (a *AsyncApi) Plugin(r *message.Router) error {
	a.router = r

    <% it.receivers.forEach(receiver => { -%>
		<% if (receiver.parameters.length === 0) { -%>
	// Handler for receive operation <%= receiver.id %>
	r.AddNoPublisherHandler(
            "<%= receiver.id %>Handler",
            "<%= receiver.channel.address %>",
            a.subscriber,
            a.wrapper<%= receiver.id %>,
	)
    	<%- } %>
	<%- }) %>

	return nil
}

<% if (parametersExists) { -%>
// Receiver handlers for channels with parameters 
<%- it.receivers.forEach(receiver => { -%>
	<%- if (receiver.parameters.length > 0) { %>
func (a AsyncApi) Add<%= receiver.id %>ChannelReceiver(parameters <%= receiver.channel.id %>Parameters) (*message.Handler, error) {
	if a.router == nil {
		panic("plugin uninitialised. call router.AddPlugin(asyncApi.Plugin) first")
	}
	
	address := marshalChannelAddress("<%= receiver.channel.address %>", parameters)

	handler := a.router.AddNoPublisherHandler(
		fmt.Sprintf("%s_Handler", address),
		address,
		a.subscriber,
		a.wrapper<%= receiver.id %>,
	)

	if err := a.router.RunHandlers(context.Background()); err != nil {
		return nil, err
	}

	return handler, nil
}
	<% } %>
<% }) %>

// Channel parameters
func marshalChannelAddress(address string, parameters interface{}) string {
	v := reflect.ValueOf(parameters)
	for i := 0; i < v.NumField(); i++ {
		pName := v.Type().Field(i).Tag.Get("parameter")
		pValue := v.Field(i).String()
		
		address = strings.ReplaceAll(address, fmt.Sprintf("{%s}", pName), pValue)
	}

	return address
}

func unmarshalChannelAddress(channel string, address string, parameters interface{}) error {
	if t := reflect.TypeOf(parameters); t.Kind() != reflect.Pointer {
		return ErrExpectedPointerType
	}

	pStruct := reflect.ValueOf(parameters).Elem()
	addressRegex := fmt.Sprintf("^%s$", address)
	for i := 0; i < pStruct.NumField(); i++ {
		pName := pStruct.Type().Field(i).Tag.Get("parameter")
		pField := pStruct.Type().Field(i).Name

		addressRegex = strings.ReplaceAll(addressRegex, fmt.Sprintf("{%s}", pName), fmt.Sprintf("(?<%= "<" %>%s>.*)", pField))
	}

	re, err := regexp.Compile(addressRegex)
	if err != nil {
		return err
	} else if !re.MatchString(channel) {
		return ErrChannelMismatchesAddress
	} else if pStruct.Kind() != reflect.Struct {
		return ErrExpectedStruct
	}
	
	subMatch := re.FindStringSubmatch(channel)
	for i, pField := range re.SubexpNames() {
		if i == 0 { continue }

		f := pStruct.FieldByName(pField)
		if f.IsValid() && f.CanSet() && f.Kind() == reflect.String {
			f.SetString(subMatch[i])
		} else {
			return ErrParameterCouldNotSetValue
		}
	}

	return nil
}
<%- } %>

<% it.channels.forEach(channel => { -%>
	<%- if (channel.parameters.length > 0) { %>
type <%= channel.id %>Parameters struct {
	<% channel.parameters.forEach(param => { -%>
	<%= param.name %> string `parameter:"<%= param.id %>"`
	<% }) %>
}
	<% } -%>
<%- }) %>

<% if (it.senders.length > 0) { -%>
// Send Operation 
<%- it.senders.forEach(sender => { -%>
	<%- sender.messages.forEach( message => { -%>
		<%- if (sender.parameters.length > 0) { %>
func (a AsyncApi) <%= sender.id %>_<%= message.id %>(uuid string, payload <%= message.channel %>_<%= message.id %>, parameters <%= message.channel %>Parameters) error {
	msg, err := NewMessage(uuid, payload)
	if err != nil {
		return err
	}
	address := marshalChannelAddress("<%= sender.channel.address %>", parameters)
	return a.publisher.Publish(address, msg.Raw())
}
<% } else { %>
func (a AsyncApi) <%= sender.id %>_<%= message.id %>(uuid string, payload <%= message.channel %>_<%= message.id %>) error {
	msg, err := NewMessage(uuid, payload)
	if err != nil {
		return err
	}
	return a.publisher.Publish("<%= sender.channel.address %>", msg.Raw())
}
		<% } -%>
	<% }) -%>
<% }) -%>
<% } %>

<% if (it.receivers.length > 0) { -%>
// Receiver wrapper 
<%- it.receivers.forEach(receiver => { %>
func (a AsyncApi) wrapper<%= receiver.id %>(m *message.Message) error {
	msg := Message{}
	if err := msg.Load(m); err != nil {
		return err
	}

	<% if (receiver.parameters.length > 0) { -%>
	// extract parameters from channel
	channel := message.SubscribeTopicFromCtx(m.Context())
	var parameters <%= receiver.channel.id %>Parameters
	if err := unmarshalChannelAddress(channel, "<%= receiver.channel.address %>", &parameters); err != nil {
		return err
	}
	<% } %>

	switch msg.Id() {
    <% receiver.messages.forEach(message => { -%>
	case "<%= message.id %>":
		var payload <%= message.channel %>_<%= message.id %>
		if err := msg.Unmarshal(&payload); err != nil {
			return err
		}

		<% if (receiver.parameters.length === 0) { -%>
		return a.receiver.<%= receiver.id %>_<%= message.id %>(msg, payload)
		<%- } else { -%>
		return a.receiver.<%= receiver.id %>_<%= message.id %>(msg, payload, parameters)
		<%- } -%>
    <%- }) -%>
	default:
		return ErrUnknownMessageId
	}
}
<% }) %>
<%- } %>
