// DO NOT EDIT. This file is autogenerated by aapi-codegen
package <%= it.package %>

import (
	"encoding/json"
	"errors"
	"reflect"
	"strings"

	"github.com/ThreeDotsLabs/watermill/message"

	// Model dependencies  
	<%- it.dependencies.forEach(dependency => { -%>
	"<%= dependency %>"
	<% }) %>
)

const (
	// Spec document
	AsyncapiDocumentVersion string = "<%= it.version %>"

	// Content-Types
	ApplicationJson string = "application/json"

	// Metadata fields
	MessageId   string = "Message-Id"
	ContentType string = "Content-Type"
	SpecVersion string = "Spec-Version"
)

var (
	ErrMessageAlreadyLoaded   = errors.New("message already loaded")
	ErrUnsupportedContentType = errors.New("message content type is not supported")
	ErrExpectedPointerType    = errors.New("expected a pointer")
	ErrTypeMismatch           = errors.New("mismatch of message and struct type")
)

type Message struct {
	msg *message.Message
}

func NewMessage(uuid string, m interface{}) (*Message, error) {
	var mId string
	if t := reflect.TypeOf(m); t.Kind() == reflect.Pointer {
		mId = trimMsgPayload(t.Elem().Name())
	} else {
		mId = trimMsgPayload(t.Name())
	}

	data, err := json.Marshal(m)
	if err != nil {
		return nil, err
	}

	msg := message.NewMessage(uuid, data)
	msg.Metadata.Set(MessageId, mId)
	msg.Metadata.Set(ContentType, ApplicationJson)
	msg.Metadata.Set(SpecVersion, AsyncapiDocumentVersion)

	return &Message{msg}, nil
}

func (m *Message) Load(msg *message.Message) error {
	if m.msg != nil {
		return ErrMessageAlreadyLoaded
	}

	m.msg = msg
	return nil
}

func (m Message) Raw() *message.Message {
	return m.msg
}

func (msg Message) Unmarshal(m interface{}) error {
	mt := reflect.TypeOf(m)
	if mt.Kind() != reflect.Pointer {
		return ErrExpectedPointerType
	}

	if msg.MsgId() != trimMsgPayload(mt.Elem().Name()) {
		return ErrTypeMismatch
	}

	switch msg.ContentType() {
	case ApplicationJson:
		return json.Unmarshal(msg.msg.Payload, m)
	default:
		return ErrUnsupportedContentType
	}
}

func trimMsgPayload(s string) string {
	return strings.TrimSuffix(s, "MsgPayload")
}

func (m Message) UUID() string {
	return m.msg.UUID
}

func (m Message) MsgId() string {
	return m.msg.Metadata.Get(MessageId)
}

func (m Message) ContentType() string {
	return m.msg.Metadata.Get(ContentType)
}

func (m Message) SpecVersion() string {
	return m.msg.Metadata.Get(SpecVersion)
}

func (m Message) Ack() bool {
	return m.msg.Ack()
}

func (m Message) Nack() bool {
	return m.msg.Nack()
}

// Models
<%- it.models.forEach(model => { %>
<%= model %>
<% }) %>

<% it.messages.forEach(message => { %>
// <%= message.name %>MsgPayload implements message <%= message.id %>
type <%= message.name %>MsgPayload struct {
	<%= message.payload %>
}
<% }) %>

<% it.messages.forEach(message => { %>
// <%= message.name %>RecvMsg implements message <%= message.id %> for message received by a channel
type <%= message.name %>RecvMsg struct {
	Message
}

func (m <%= message.name %>RecvMsg) UnmarshalPayload() (<%= message.name %>MsgPayload, error) {
	var payload <%= message.name %>MsgPayload
	if err := m.Unmarshal(&payload); err != nil {
		return <%= message.name %>MsgPayload{}, err
	}
	return payload, nil
}
<% }) %>
